#args: source, mountpoint
_mnt_bind()
{
    msg "::: Binding ${1} to ${2}"
    mkdir -p /real_root${2}
    /bin/mount -o bind ${addon_dir}/${1} /real_root${2}
}

# args: image file
_mnt_squashfs()
{
    msg "::: Adding new real_root branch: ${1}"
    /bin/modprobe -q loop max_loop=255 >/dev/null 2>&1
    mkdir -p "/tmpfs/mnt/loop${LOOP_NUM}"
    if ! /bin/losetup "/dev/loop${LOOP_NUM}" ${1} > /dev/null 2>&1; then
        echo "ERROR: Cannot mount loop device /dev/loop${LOOP_NUM}"
        echo "       Couldn't mount all addons"
        break
    fi
    /bin/mount -r -t squashfs "/dev/loop${LOOP_NUM}" "/tmpfs/mnt/loop${LOOP_NUM}"

    /bin/mount -t aufs -o remount,add:1:/tmpfs/mnt/loop${LOOP_NUM}=rr aufs "/real_root"
    export LOOP_NUM=$(( $LOOP_NUM + 1 ))
}

run_hook ()
{
	export LOOP_NUM="0"
    
    if [ "x${from}" != "x" ]; then
	BOOT_MOUNT="/live"
    fi
    
	if [ ! $(ls /dev/loop*) ]; then
		echo "Creating loop device nodes."
		mknod /dev/loop0 b 7 0
		mknod /dev/loop1 b 7 1
		mknod /dev/loop2 b 7 2
		mknod /dev/loop3 b 7 3
		mknod /dev/loop4 b 7 4
	fi
	
    if [ -f "${BOOT_MOUNT}/initrd.lzm" ]; then
		#mount_tmpfs
		mkdir -p "/tmpfs/initrd"
		/bin/modprobe -q squashfs >/dev/null 2>&1
		/bin/modprobe -q sqlzma >/dev/null 2>&1
		/bin/modprobe -q unlzma >/dev/null 2>&1
		/bin/modprobe -q aufs brs=1 >/dev/null 2>&1
		/bin/mount -t aufs -o nowarn_perm,br:/tmpfs=rw aufs /real_root
		_mnt_squashfs "${BOOT_MOUNT}/initrd.lzm"
		
		if [ "${break}" = "y" ]; then
			echo ":: Break requested, type 'exit' to resume operation"
			echo "   NOTE: klibc contains no 'ls' binary, use 'echo *' instead"
			PS1="ramfs$ " /bin/sh -i
		fi
		
		udevpid=$(/bin/minips -C udevd -o pid=)
		[ "x${udevpid}" != "x" ] && /bin/kill -9 $udevpid 2>&1 >/dev/null
		#Yep, we're bailing out here.  We don't need kinit.
		msg ":: Passing control to Archlinux Initscripts...Please Wait"
		/bin/umount /sys
		/bin/umount /proc
		exec /bin/run-init -c /dev/console /real_root /sbin/init
    fi

}

# vim:ft=sh:ts=4:sw=4:et:
