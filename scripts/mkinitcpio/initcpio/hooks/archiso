# args: source, mountpoint
_mnt_aufs() {
    src="${1}"
    mnt="${2}"
    msg "::: Adding new aufs branch: ${src} to ${mnt}"
    mkdir -p "${mnt}"
    /bin/mount -t aufs -o remount,append:"${src}"=ro aufs "${mnt}"
}

# args: source, mountpoint
_mnt_bind() {
    src="${1}"
    mnt="${2}"
    msg "::: Binding ${src} to ${mnt}"
    mkdir -p "${mnt}"
    /bin/mount -o bind "${src}" "${mnt}"
}

# args: source, mountpoint
_mnt_move() {
    src="${1}"
    mnt="${2}"
    msg "::: Moving ${src} to ${mnt}"
    mkdir -p "${mnt}"
    /bin/mount -o move "${src}" "${mnt}"
}

_mnt_iso() {
    img="${1}"
    #mnt="${2}"
    mnt="/tmpfs/mnt/findiso"
    msg "::: Mounting ${img} to ${mnt}"
    mkdir -p "${mnt}"
    mount -r -t iso9660 "${img}" "${mnt}"
}

# args: /path/to/image_file, mountpoint
_mnt_squashfs() {
    img="${1}"
    mnt="${2}"
    img_fullname="${img##*/}";
    img_name="${img_fullname%.*}"
    tmp_mnt="/tmpfs/mnt/${img_name}"

    if [ "${copytoram}" = "y" ]; then
        msg -n ":: Copying squashfs image to RAM..."
        /bin/cp "${img}" "/tmpfs.sqfs/${img_fullname}"
        img="/tmpfs.sqfs/${img_fullname}"
        msg "done."
    fi

    mkdir -p "${tmp_mnt}"
    /bin/mount -r -t squashfs "${img}" "${tmp_mnt}"
    _mnt_aufs "${tmp_mnt}" "${mnt}"
}

_mnt_tmpfs () {
    #if [ "x${ramdisk_size}" = "x" ]; then
        ramdisk_size="3M"
    #fi
    msg ":: Mounting tmpfs, size=${ramdisk_size}... "
    mount -t tmpfs -o "size=${ramdisk_size}" tmpfs /tmpfs
    msg "done."; echo
}

run_hook () {

    _mnt_tmpfs

    # external drives may need to settle
    msg "Waiting for devices to settle..."
    /sbin/udevadm trigger --subsystem-match=usb
    /sbin/udevadm settle
    usbdelay=$(( ${usbdelay:-0} + 1 ))
    msg "Waiting ${usbdelay}s for USB devices"
    sleep "${usbdelay}"

    found=0
    
    modprobe -q loop max_loop=255 >/dev/null 2>&1
    modprobe -q isofs >/dev/null 2>&1
    modprobe -q ext4 >/dev/null 2>&1
    msg "Scanning drives: "
    for device in /dev/hd[a-z] /dev/sr[0-9]* /dev/scd[a-z] /dev/sg[0-9]* /dev/sd[a-z][0-9]; do
        [ ! -e "${device}" ] && continue
        FSTYPE=$(blkid -o value -s TYPE ${device})
        bootmnt="/tmpfs/mnt/${device##*/}"
        mkdir -p "${bootmnt}"
        if mount -t ${FSTYPE} "${device}" "${bootmnt}" >/dev/null 2>&1; then
            if [ -f "${bootmnt}/${findiso}" ]; then
                found=1
                msg "${device}"; echo
                BOOT_MOUNT="${bootmnt}"
                break
            elif [ "x${from}" != "x" ]; then
                from=$(${from##*/})
                if [ -f "${bootmnt}/${from}/base.lzm" ]; then
                    found=1
                    msg "${device}"; echo
                    BOOT_MOUNT="${bootmnt}"
                    break
                fi
            else
                if [ -f "${bootmnt}/base.lzm" ]; then
                    found=1
                    msg "${device}"; echo
                    BOOT_MOUNT="${bootmnt}"
                    break
                fi
            fi   
        else
            msg "uhm"; echo
            err "Failed to mount ${device} (FS is ${FSTYPE})"
        fi
        [ ${found} -eq 0 ] && umount "${bootmnt}" >/dev/null 2>&1
    done

    if [ ${found} -eq 0 ]; then
        err "cannot find boot device, cannot continue..."
        msg "Falling back to interactive prompt"
        PS1="ramfs$ " /bin/sh -i
        exit 1
    fi

    if [ "${break}" = "y" ]; then
        msg "Break requested, type 'exit' to resume operation"
        PS1="ramfs$ " /bin/sh -i
    fi

    modprobe -q squashfs >/dev/null 2>&1
    modprobe -q aufs brs=1 >/dev/null 2>&1
    XINO=xino
    MEMORY=memory
    if [ "$XINO" != "$MEMORY" ]; then
    	mkdir -p $XINO
    	mount -n -t tmpfs tmpfs $XINO
    fi

    mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:/tmpfs=rw aufs /real_root
    if [ $? -ne 0 ]; then
        err "while mounting root (aufs) fileystem."
        exit 1
    fi

    if [ "x${findiso}" != "x" ]; then
        if [ -f "${BOOT_MOUNT}/${findiso}" ]; then
            _mnt_iso "${BOOT_MOUNT}/${findiso}"
            BOOT_ORIG="${BOOT_MOUNT}"
            BOOT_MOUNT="/tmpfs/mnt/findiso"
        fi

        if [ -f "${BOOT_MOUNT}/base.lzm" ]; then
            _mnt_squashfs "${BOOT_MOUNT}/base.lzm" "/real_root"
        elif [ -f "${BOOT_MOUNT}/initrd.lzm" ]; then
            _mnt_squashfs "${BOOT_MOUNT}/initrd.lzm" "/real_root"
        fi
    elif [ "x${from}" != "x" ]; then
       _mnt_squashfs "${BOOT_MOUNT}/${from}/base.lzm" "/real_root"
    else
       _mnt_squashfs "${BOOT_MOUNT}/base.lzm" "/real_root"
    fi
    
    echo "aufs / aufs defaults 0 0" > /real_root/etc/fstab
    _mnt_move ${BOOT_MOUNT} /real_root/mnt/${BOOT_MOUNT##*/}
    if [ "x${findiso}" != x ]; then
        _mnt_move ${BOOT_ORIG} /real_root/mnt/${BOOT_ORIG##*/}
    fi

    if [ "${break}" = "y" ]; then
        msg ":: Break requested, type 'exit' to resume operation"
        PS1="ramfs$ " /bin/sh -i
    fi
		
    ROOT=/real_root
    mkdir -p $ROOT/dev 2>&1 >/dev/null
    mknod $ROOT/dev/console c 5 1 2>&1 >/dev/null
    mknod $ROOT/dev/null c 1 3 2>&1 >/dev/null
    mknod $ROOT/dev/zero c 1 5 2>&1 >/dev/null

    #Special handling if udev is running
    udevpid=$(/bin/pidof udevd)
    if [ -n "${udevpid}" ]; then
        /bin/kill -9 ${udevpid} > /dev/null 2>&1
        /bin/sleep 0.01
    fi
    msg ":: Passing control to Linux-Live Initrd...Please Wait"
    umount -l /sys
    umount -l /proc
    sleep 2
    exec /sbin/switch_root -c /dev/console /real_root /sbin/init
}

# vim:ft=sh:ts=4:sw=4:et:
